<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2//EN">
<!-- Generated by pod2coolhtml 1.101
  -- Using Pod::CoolHTML 1.104 , (C) 1997 by Eryq (eryq@enteract.com).
  --
  -- DO NOT EDIT THIS HTML FILE! All your changes will be lost.
  -- Edit the POD or Perl file that was used to create it.
  -->
<HTML>

<HEAD>
<TITLE>Text::Refer</TITLE>
</HEAD>
<BODY LINK=#C00000 ALINK=#FF2020 VLINK=#900000>
<A NAME="__top"> </A><TABLE WIDTH="100%">

<TR VALIGN="TOP"><TD ALIGN="LEFT"><CENTER>
<H1><FONT SIZE=7 COLOR=#600020><B>Text::<BR>Refer</B></FONT></H1></CENTER>
<TD>
<UL>
<LI><A HREF="#name">NAME</A>
</LI><LI><A HREF="#synopsis">SYNOPSIS</A>
</LI><LI><A HREF="#description">DESCRIPTION</A>
</LI><UL>
<LI><A HREF="#example">Example</A>
</LI><LI><A HREF="#syntax">Syntax</A>
</LI><LI><A HREF="#parsing_records_from_refer_files">Parsing records from &quot;refer&quot; files</A>
</LI></UL>
<LI><A HREF="#class_textrefer">CLASS Text::Refer</A>
</LI><UL>
<LI><A HREF="#construction_and_input">Construction and input</A>
</LI><LI><A HREF="#gettingsetting_attributes">Getting/setting attributes</A>
</LI><LI><A HREF="#output">Output</A>
</LI></UL>
<LI><A HREF="#class_textreferparser">CLASS Text::Refer::Parser</A>
</LI><UL>
<LI><A HREF="#parser_options">Parser options</A>
</LI><LI><A HREF="#notes_on_the_parser_options">Notes on the parser options</A>
</LI><LI><A HREF="#public_interface">Public interface</A>
</LI></UL>
<LI><A HREF="#notes">NOTES</A>
</LI><UL>
<LI><A HREF="#under_the_hood">Under the hood</A>
</LI><LI><A HREF="#performance">Performance</A>
</LI><LI><A HREF="#note_to_serious_bibfile_users">Note to serious bib-file users</A>
</LI></UL>
<LI><A HREF="#bugs">BUGS</A>
</LI><LI><A HREF="#change_log">CHANGE LOG</A>
</LI><LI><A HREF="#author">AUTHOR</A>
</LI><LI><A HREF="#no_warranty">NO WARRANTY</A>
</LI></UL>

</TABLE>

<P><HR>
<A NAME="name">
<H1><FONT COLOR=#600020>
<A HREF="#__top"><IMG SRC="Refer-gifs/h1bullet.gif" ALT="" BORDER="0"></A>
NAME</FONT></H1>
</A>


<P>
Text::Refer - parse Unix &quot;refer&quot; files


<P>
<I>This is Alpha code, and may be subject to changes in its public
interface.  It will stabilize by June 1997, at which point this 
notice will be removed.  Until then, if you have any feedback,
please let me know!</I>


<P><HR>
<A NAME="synopsis">
<H1><FONT COLOR=#600020>
<A HREF="#__top"><IMG SRC="Refer-gifs/h1bullet.gif" ALT="" BORDER="0"></A>
SYNOPSIS</FONT></H1>
</A>


<P>
Pull in the module:


<P>
<PRE>    use Text::Refer;  </PRE>



<P>
Parse a refer stream from a filehandle:


<P>
<PRE>    while (&#36;ref = input Text::Refer \*FH)  {
	# ...do stuff with &#36;ref...
    }
    defined(&#36;ref) or die &quot;error parsing input&quot;;</PRE>



<P>
Same, but using a parser object for more control:


<P>
<PRE>    # Create a new parser: 
    &#36;parser = new Text::Refer::Parser LeadWhite=&gt;'KEEP';</PRE>



<P>
<PRE>    # Parse:
    while (&#36;ref = &#36;parser-&gt;input(\*FH))  {
	# ...do stuff with &#36;ref...
    }
    defined(&#36;ref) or die &quot;error parsing input&quot;;</PRE>



<P>
Manipulating reference objects, using high-level methods:


<P>
<PRE>    # Get the title, author, etc.:
    &#36;title      = &#36;ref-&gt;title;
    @authors    = &#36;ref-&gt;author;      # list context
    &#36;lastAuthor = &#36;ref-&gt;author;      # scalar context</PRE>



<P>
<PRE>    # Set the title and authors:
    &#36;ref-&gt;title(&quot;Cyberiad&quot;);
    &#36;ref-&gt;author([&quot;S. Trurl&quot;, &quot;C. Klapaucius&quot;]);   # arrayref for &gt;1 value!</PRE>



<P>
<PRE>    # Delete the abstract:
    &#36;ref-&gt;abstract(undef);</PRE>



<P>
Same, using low-level methods:


<P>
<PRE>    # Get the title, author, etc.:
    &#36;title      = &#36;ref-&gt;get('T');
    @authors    = &#36;ref-&gt;get('A');      # list context
    &#36;lastAuthor = &#36;ref-&gt;get('A');      # scalar context</PRE>



<P>
<PRE>    # Set the title and authors:
    &#36;ref-&gt;set('T', &quot;Cyberiad&quot;);
    &#36;ref-&gt;set('A', &quot;S. Trurl&quot;, &quot;C. Klapaucius&quot;);</PRE>



<P>
<PRE>    # Delete the abstract:
    &#36;ref-&gt;set('X');                    # sets to empty array of values</PRE>



<P>
Output:


<P>
<PRE>    print &#36;ref-&gt;as_string;</PRE>



<P><HR>
<A NAME="description">
<H1><FONT COLOR=#600020>
<A HREF="#__top"><IMG SRC="Refer-gifs/h1bullet.gif" ALT="" BORDER="0"></A>
DESCRIPTION</FONT></H1>
</A>


<P>
<I>This module supercedes the old Text::Bib.</I>


<P>
This module provides routines for parsing in the contents of
&quot;refer&quot;-format bibliographic databases: these are simple text files
which contain one or more bibliography records.  They are usually found
lurking on Unix-like operating systems, with the extension <I>.bib</I>.


<P>
Each record in a &quot;refer&quot; file describes a single paper, book, or article.  
Users of nroff/troff often employ such databases when typesetting papers.


<P>
Even if you don't use *roff, this simple, easily-parsed parameter-value 
format is still useful for recording/exchanging bibliographic 
information.  With this module, you can easily post-process
&quot;refer&quot; files: search them, convert them into LaTeX, whatever.


<P><HR>
<A NAME="example">
<H2><FONT COLOR=#600020>
<A HREF="#__top"><IMG SRC="Refer-gifs/h2bullet.gif" ALT="" BORDER="0"></A>
Example</FONT></H2>
</A>


<P>
Here's a possible &quot;refer&quot; file with three entries:


<P>
<PRE>    &#37;T Cyberiad
    &#37;A Stanislaw Lem
    &#37;K robot fable 
    &#37;I Harcourt/Brace/Jovanovich</PRE>



<P>
<PRE>    &#37;T Invisible Cities
    &#37;A Italo Calvino
    &#37;K city fable philosophy
    &#37;X In this surreal series of fables, Marco Polo tells an
       aged Kublai Khan of the many cities he has visited in 
       his lifetime.  </PRE>



<P>
<PRE>    &#37;T Angels and Visitations
    &#37;A Neil Gaiman 
    &#37;D 1993</PRE>



<P>
The lines separating the records must be <I>completely blank</I>;
that is, they cannot contain anything but a single newline.


<P>
See refer(1) or grefer(1) for more information on &quot;refer&quot; files.


<P><HR>
<A NAME="syntax">
<H2><FONT COLOR=#600020>
<A HREF="#__top"><IMG SRC="Refer-gifs/h2bullet.gif" ALT="" BORDER="0"></A>
Syntax</FONT></H2>
</A>


<P>
<I>From the GNU manpage, <CODE>grefer(1)</CODE>:</I>


<P>
The  bibliographic  database  is a text file consisting of
records separated by one or more blank lines.  Within each
record  fields  start with a &#37; at the beginning of a line.
Each field has a one character name that immediately  follows  
the  &#37;.  It is best to use only upper and lower case
letters for the names of fields. The name  of  the  field
should  be  followed by exactly one space, and then by the
contents of the field.  Empty  fields  are  ignored.   The
conventional meaning of each field is as follows:

<DL>
<P><DT><B><A NAME="a">A</A></B><DD>

The name of an author. If the name contains a
title such as Jr. at the end, it should	be separated  
from the last name by a comma.  There can be multiple 
occurrences of the A field.  The order is significant. 
It is a good idea always to supply an A field or a Q field.


<P><DT><B><A NAME="b">B</A></B><DD>

For an article that is part of a book, the title of the book


<P><DT><B><A NAME="c">C</A></B><DD>

The place (city) of publication.


<P><DT><B><A NAME="d">D</A></B><DD>

The date of publication.  The year should be specified in full.  
If the month is specified, the name rather than the number of 
the month should be used, but only the first three letters are required.   
It is a good idea always to supply a D field; if the date is unknown, 
a value such as &quot;in press&quot; or &quot;unknown&quot; can be used.


<P><DT><B><A NAME="e">E</A></B><DD>

For  an article that is part of a book, the name of an editor of the book.  
Where the work has editors and no authors, the names of the editors should 
be  given as A fields and , (ed) or , (eds)  should  be
appended to the last author.


<P><DT><B><A NAME="g">G</A></B><DD>

US Government ordering number.


<P><DT><B><A NAME="i">I</A></B><DD>

The publisher (issuer).


<P><DT><B><A NAME="j">J</A></B><DD>

For an article in a journal, the name of the journal.


<P><DT><B><A NAME="k">K</A></B><DD>

Keywords to be used for searching.


<P><DT><B><A NAME="l">L</A></B><DD>

Label.


<P>
<B>NOTE:</B> Uniquely identifies the entry.  For example, &quot;Able94&quot;.


<P><DT><B><A NAME="n">N</A></B><DD>

Journal issue number.


<P><DT><B><A NAME="o">O</A></B><DD>

Other information.  This is usually printed at the end of the reference.


<P><DT><B><A NAME="p">P</A></B><DD>

Page number.  A range of pages can be specified as m-n.


<P><DT><B><A NAME="q">Q</A></B><DD>

The name of the author, if the author is not a person.   
This will only be used if there are no A fields.  There can only be one 
Q field.


<P>
<B>NOTE:</B> Thanks to Mike Zimmerman for clarifying this for me:
it means a &quot;corporate&quot; author: when the &quot;author&quot; is listed
as an organization such as the UN, or RAND Corporation, or whatever.


<P><DT><B><A NAME="r">R</A></B><DD>

Technical report number.


<P><DT><B><A NAME="s">S</A></B><DD>

Series name.


<P><DT><B><A NAME="t">T</A></B><DD>

Title.  For an article in a book or journal, this should be the title 
of the article.


<P><DT><B><A NAME="v">V</A></B><DD>

Volume number of the journal or book.


<P><DT><B><A NAME="x">X</A></B><DD>

Annotation.


<P>
<B>NOTE:</B> Basically, a brief abstract or description.

</DL>

<P>
For all fields except A and E, if there is more than one occurrence
of a particular field in a record, only the last such field will be used.


<P>
If accent strings are used, they should follow the character 
to be accented.  This means that the AM macro must  be
used  with  the -ms macros.  Accent strings should not be
quoted: use one \ rather than two.


<P><HR>
<A NAME="parsing_records_from_refer_files">
<H2><FONT COLOR=#600020>
<A HREF="#__top"><IMG SRC="Refer-gifs/h2bullet.gif" ALT="" BORDER="0"></A>
Parsing records from &quot;refer&quot; files</FONT></H2>
</A>


<P>
You will nearly always use the <CODE>input()</CODE> constructor to create
new instances, and nearly always as shown in the <A HREF="#synopsis">&quot;SYNOPSIS&quot;</A>.


<P>
Internally, the records are parsed by a parser object; if you 
invoke the class method <CODE>Text::Refer::input()</CODE>, a special default parser 
is used, and this will be good enough for most tasks.  However, for
more complex tasks, feel free to use <A HREF="#class_textreferparser">&quot;class Text::Refer::Parser&quot;</A>
to build (and use) your own fine-tuned parser, and <CODE>input()</CODE> from
that instead.


<P><HR>
<A NAME="class_textrefer">
<H1><FONT COLOR=#600020>
<A HREF="#__top"><IMG SRC="Refer-gifs/h1bullet.gif" ALT="" BORDER="0"></A>
CLASS Text::Refer</FONT></H1>
</A>


<P>
Each instance of this class represents a single record in a &quot;refer&quot; file.


<P><HR>
<A NAME="construction_and_input">
<H2><FONT COLOR=#600020>
<A HREF="#__top"><IMG SRC="Refer-gifs/h2bullet.gif" ALT="" BORDER="0"></A>
Construction and input</FONT></H2>
</A>

<DL>
<P><DT><B><A NAME="new">new</A></B><DD>

<I>Class method, constructor.</I>
Build an empty &quot;refer&quot; record.


<P><DT><B><A NAME="input">input FILEHANDLE</A></B><DD>

<I>Class method.</I>
Input a new &quot;refer&quot; record from a filehandle.  The default parser
is used:


<P>
<PRE>    while (&#36;ref = input Text::Refer \*STDIN) {
	# ...do stuff with &#36;ref...
    }</PRE>



<P>
Do <I>not</I> use this as an instance method; it will not re-init the object
you give it.

</DL>

<P><HR>
<A NAME="gettingsetting_attributes">
<H2><FONT COLOR=#600020>
<A HREF="#__top"><IMG SRC="Refer-gifs/h2bullet.gif" ALT="" BORDER="0"></A>
Getting/setting attributes</FONT></H2>
</A>

<DL>
<P><DT><B><A NAME="attr">attr ATTR, [VALUE]</A></B><DD>

<I>Instance method.</I>
Get/set the attribute by its one-character name, ATTR.
The VALUE is optional, and may be given in a number of ways:

<UL>

<P><LI><B>If the VALUE is given as undefined</B>, the attribute will be deleted:


<P>
<PRE>    &#36;ref-&gt;attr('X', undef);        # delete the abstract</PRE>



<P><LI><B>If a defined, non-reference scalar VALUE is given,</B> it is used to 
replace the existing values for the attribute with that <I>single</I> value:


<P>
<PRE>    &#36;ref-&gt;attr('T', &quot;The Police State Rears Its Ugly Head&quot;);
    &#36;ref-&gt;attr('D', 1997);</PRE>



<P><LI><B>If an arrayref VALUE is given,</B> it is used to replace the existing values
for the attribute with <I>all elements of that array:</I>


<P>
<PRE>    &#36;ref-&gt;attr('A', [&quot;S. Trurl&quot;, &quot;C. Klapaucius&quot;]);</PRE>



<P>
We use an arrayref since an empty array would be impossible to distinguish
from the next two cases, where the goal is to &quot;get&quot; instead of &quot;set&quot;...

</UL>


<P>
This method returns the current (or new) value of the given attribute,
just as <CODE>get()</CODE> does:

<UL>

<P><LI><B>If invoked in a <I>scalar</I> context,</B> the method will return the
<I>last</I> value (this is to mimic the behavior of <I>groff</I>).  Hence,
given the above, the code:


<P>
<PRE>    &#36;author = &#36;ref-&gt;attr('A');</PRE>



<P>
will set <CODE>&#36;author</CODE> to <CODE>&quot;C. Klapaucius&quot;</CODE>.


<P><LI><B>If invoked in an <I>array</I> context,</B> the method will return the list 
of <I>all</I> values, in order.  Hence, given the above, the code:


<P>
<PRE>    @authors = &#36;ref-&gt;attr('A');</PRE>



<P>
will set <CODE>@authors</CODE> to <CODE>(&quot;S. Trurl&quot;, &quot;C. Klapaucius&quot;)</CODE>.

</UL>


<P>
<I>Note:</I> this method is used as the basis of all &quot;named&quot; access 
methods; hence, the following are equivalent in every way:


<P>
<PRE>    &#36;ref-&gt;attr(T =&gt; &#36;title)    &lt;=&gt;   &#36;ref-&gt;title(&#36;title);
    &#36;ref-&gt;attr(A =&gt; \@authors) &lt;=&gt;   &#36;ref-&gt;author(\@authors);
    &#36;ref-&gt;attr(D =&gt; undef)     &lt;=&gt;   &#36;ref-&gt;date(undef);
    &#36;auth  = &#36;ref-&gt;attr('A')   &lt;=&gt;   &#36;auth  = &#36;ref-&gt;author;
    @auths = &#36;ref-&gt;attr('A')   &lt;=&gt;   @auths = &#36;ref-&gt;author;</PRE>



<P><DT><B><A NAME="author">author, book, city, ... [VALUE]</A></B><DD>

<I>Instance methods.</I>
For every one of the standard fields in a &quot;refer&quot; record, this
module has designated a high-level attribute name:


<P>
<PRE>   A  author     G  govt_no      N  number        S  series   
   B  book       I  publisher    O  other_info    T  title     
   C  city       J  journal      P  page          V  volume    
   D  date       K  keywords     Q  corp_author   X  abstract  
   E  editor     L  label        R  report_no    </PRE>



<P>
Then, for each field <I>F</I> with high-level attribute name <I>FIELDNAME</I>,
the method <CODE>FIELDNAME()</CODE> works as follows:


<P>
<PRE>    &#36;ref-&gt;attr('F', @args)     &lt;=&gt;   &#36;ref-&gt;FIELDNAME(@args)</PRE>



<P>
Which means:


<P>
<PRE>    &#36;ref-&gt;attr(T =&gt; &#36;title)    &lt;=&gt;   &#36;ref-&gt;title(&#36;title);
    &#36;ref-&gt;attr(A =&gt; \@authors) &lt;=&gt;   &#36;ref-&gt;author(\@authors);
    &#36;ref-&gt;attr(D =&gt; undef)     &lt;=&gt;   &#36;ref-&gt;date(undef);
    &#36;auth  = &#36;ref-&gt;attr('A')   &lt;=&gt;   &#36;auth  = &#36;ref-&gt;author;
    @auths = &#36;ref-&gt;attr('A')   &lt;=&gt;   @auths = &#36;ref-&gt;author;</PRE>



<P>
See the documentation of <CODE>attr()</CODE> for the argument list.


<P><DT><B><A NAME="get">get ATTR</A></B><DD>

<I>Instance method.</I>
Get an attribute, by its one-character name.  
In an array context, it returns all values (empty if none):


<P>
<PRE>    @authors = &#36;ref-&gt;get('A');      # returns list of all authors</PRE>



<P>
In a scalar context, it returns the <I>last</I> value (undefined if none):


<P>
<PRE>    &#36;author = &#36;ref-&gt;get('A');       # returns the last author</PRE>



<P><DT><B><A NAME="set">set ATTR, VALUES...</A></B><DD>

<I>Instance method.</I>
Set an attribute, by its one-character name.


<P>
<PRE>    &#36;ref-&gt;set('A', &quot;S. Trurl&quot;, &quot;C. Klapaucius&quot;);</PRE>



<P>
An empty array of VALUES deletes the attribute:


<P>
<PRE>    &#36;ref-&gt;set('A');       # deletes all authors</PRE>



<P>
No useful return value is currently defined.

</DL>

<P><HR>
<A NAME="output">
<H2><FONT COLOR=#600020>
<A HREF="#__top"><IMG SRC="Refer-gifs/h2bullet.gif" ALT="" BORDER="0"></A>
Output</FONT></H2>
</A>

<DL>
<P><DT><B><A NAME="as_string">as_string [OPTSHASH]</A></B><DD>

<I>Instance method.</I>
Return the &quot;refer&quot; record as a string, usually for printing:


<P>
<PRE>    print &#36;ref-&gt;as_string;</PRE>



<P>
The options are:

<DL>
<P><DT><B><A NAME="quick">Quick</A></B><DD>

If true, do it quickly, but unsafely.  
<I>This does no fixup on the values at all:</I> they are output as-is.  
That means if you used parser-options which destroyed any of the 
formatting whitespace (e.g., <CODE>Newline=TOSPACE</CODE> with <CODE>LeadWhite=KILLALL</CODE>), 
there is a risk that the output object will be an invalid &quot;refer&quot; record.

</DL>

<P>
The fields are output with &#37;L first (if it exists), and then the 
remaining fields in alphabetical order.  The following &quot;safety measures&quot; 
are normally taken:

<UL>

<P><LI>Lines longer than 76 characters are wrapped (if possible, at a non-word
character a reasonable length in, but there is a chance that they will
simply be &quot;split&quot; if no such character is available).


<P><LI>Any occurences of '&#37;' immediately after a newline are preceded by a 
single space.

</UL>


<P>
These safety measures are slightly time-consuming, and are silly if you
are merely outputting a &quot;refer&quot; object which you have read in verbatim 
(i.e., using the default parser-options) from a valid &quot;refer&quot; file.
In these cases, you may want to use the <B>Quick</B> option.

</DL>

<P><HR>
<A NAME="class_textreferparser">
<H1><FONT COLOR=#600020>
<A HREF="#__top"><IMG SRC="Refer-gifs/h1bullet.gif" ALT="" BORDER="0"></A>
CLASS Text::Refer::Parser</FONT></H1>
</A>


<P>
Instances of this class do the actual parsing.


<P><HR>
<A NAME="parser_options">
<H2><FONT COLOR=#600020>
<A HREF="#__top"><IMG SRC="Refer-gifs/h2bullet.gif" ALT="" BORDER="0"></A>
Parser options</FONT></H2>
</A>


<P>
The options you may give to <CODE>new()</CODE> are as follows:

<DL>
<P><DT><B><A NAME="forgiveeof">ForgiveEOF</A></B><DD>

Normally, the last record in a file must end with a blank line, or
else this module will suspect it of being incomplete and return an
error.  However, if you give this option as true, it will allow
the last record to be terminated by an EOF.


<P><DT><B><A NAME="goodfields">GoodFields</A></B><DD>

By default, the parser accepts any (one-character) field name that is
a printable ASCII character (no whitespace).  Formally, this is:


<P>
<PRE>    [\041-\176]</PRE>



<P>
However, when compiling parser options, you can supply your own regular 
expression for validating (one-character) field names.
(<I>note:</I> you must supply the square brackets; they are there to remind 
you that you should give a well-formed single-character expression).
One standard expression is provided for you:


<P>
<PRE>    &#36;Text::Refer::GroffFields  = '[A-EGI-LN-TVX]';  # legal groff fields</PRE>



<P>
Illegal fields which are encounterd during parsing result in a syntax error.


<P>
<B>NOTE:</B> You really shouldn't use this unless you absolutely need to.
The added regular expression test slows down the parser.


<P><DT><B><A NAME="leadwhite">LeadWhite</A></B><DD>

In many &quot;refer&quot; files, continuation lines (the 2nd, 3rd, etc. lines of a 
field) are written with leading whitespace, like this:


<P>
<PRE>    &#37;T Incontrovertible Proof that Pi Equals Three
       (for Large Values of Three)
    &#37;A S. Trurl
    &#37;X The author shows how anyone can use various common household 
       objects to obtain successively less-accurate estimations of 
       pi, until finally arriving at a desired integer approximation,
       which nearly always is three.                 </PRE>



<P>
This leading whitespace serves two purposes: (1) it makes it impossible 
to mistake a continuation line for a field, since &#37; can no longer be the 
first character, and (2) it makes the entries easier to read.
The <CODE>LeadWhite</CODE> option controls what is done with this whitespace:


<P>
<PRE>    KEEP	- default; the whitespace is untouched
    KILLONE	- exactly one character of leading whitespace is removed
    KILLALL	- all leading whitespace is removed</PRE>



<P>
See the section below on &quot;using the parser options&quot; for hints and warnings.


<P><DT><B><A NAME="newline">Newline</A></B><DD>

The <CODE>Newline</CODE> option controls what is done with the newlines that
separate adjacent lines in the same field:


<P>
<PRE>    KEEP	- default; the newlines are kept in the field value
    TOSPACE	- convert each newline to a single space
    KILL	- the newlines are removed</PRE>



<P>
See the section below on &quot;using the parser options&quot; for hints and warnings.

</DL>

<P>
Default values will be used for any options which are left unspecified.


<P><HR>
<A NAME="notes_on_the_parser_options">
<H2><FONT COLOR=#600020>
<A HREF="#__top"><IMG SRC="Refer-gifs/h2bullet.gif" ALT="" BORDER="0"></A>
Notes on the parser options</FONT></H2>
</A>


<P>
The default values for <CODE>Newline</CODE> and <CODE>LeadWhite</CODE> will preserve the
input text exactly.


<P>
The <CODE>Newline=TOSPACE</CODE> option, when used in conjunction with the
<CODE>LeadWhite=KILLALL</CODE> option, effectively &quot;word-wraps&quot; the text of
each field into a single line.


<P>
<B>Be careful!</B> If you use the <CODE>Newline=KILL</CODE> option with
either the <CODE>LeadWhite=KILLONE</CODE> or the <CODE>LeadWhite=KILLALL</CODE> option,
you could end up eliminating all whitespace that separates the word
at the end of one line from the word at the beginning of the next line.


<P><HR>
<A NAME="public_interface">
<H2><FONT COLOR=#600020>
<A HREF="#__top"><IMG SRC="Refer-gifs/h2bullet.gif" ALT="" BORDER="0"></A>
Public interface</FONT></H2>
</A>

<DL>
<P><DT><B><A NAME="new">new PARAMHASH</A></B><DD>

<I>Class method, constructor.</I>
Create and return a new parser.  See above for the <A HREF="#parser_options">&quot;parser options&quot;</A>
which you may give in the PARAMHASH.


<P><DT><B><A NAME="create">create [CLASS]</A></B><DD>

<I>Instance method.</I>
What class of objects to create.
The default is <CODE>Text::Refer</CODE>.


<P><DT><B><A NAME="input">input FH</A></B><DD>

<I>Instance method.</I>
Create a new object from the next record in a &quot;refer&quot; stream.
The actual class of the object is given by the <CODE>class()</CODE> method.


<P>
Returns the object on success, '0' on <I>expected</I> end-of-file,
and undefined on error.


<P>
Having two false values makes parsing very simple: just <CODE>input()</CODE>
records until the result is false, then check to see if that last result
was 0 (end of file) or undef (failure).

</DL>

<P><HR>
<A NAME="notes">
<H1><FONT COLOR=#600020>
<A HREF="#__top"><IMG SRC="Refer-gifs/h1bullet.gif" ALT="" BORDER="0"></A>
NOTES</FONT></H1>
</A>


<P><HR>
<A NAME="under_the_hood">
<H2><FONT COLOR=#600020>
<A HREF="#__top"><IMG SRC="Refer-gifs/h2bullet.gif" ALT="" BORDER="0"></A>
Under the hood</FONT></H2>
</A>


<P>
Each &quot;refer&quot; object has instance variables corresponding to the actual
field names (<CODE>'T'</CODE>, <CODE>'A'</CODE>, etc.).  Each of these is a reference to
an array of the actual values.


<P>
Notice that, for maximum flexibility and consistency (but at the cost of
some space and access-efficiency), the semantics of &quot;refer&quot; records do
not come into play at this time: since everything resides in an array,
you can have as many &#37;K, &#37;D, etc. records as you like, and given them
entirely different semantics.


<P>
For example, the Library Of Boring Stuff That Everyone Reads (LOBSTER) uses 
the unused &#37;Y as a &quot;year&quot; field.  The parser accomodates this
case by politely not choking on LOBSTER .bibs (although why you would
want to eat a lobster bib instead of the lobster is beyond me...).


<P><HR>
<A NAME="performance">
<H2><FONT COLOR=#600020>
<A HREF="#__top"><IMG SRC="Refer-gifs/h2bullet.gif" ALT="" BORDER="0"></A>
Performance</FONT></H2>
</A>


<P>
Tolerable.  On my 90MHz/32 MB RAM/I586 box running Linux 1.2.13 and Perl5.002,
it parses a typical 500 KB &quot;refer&quot; file (of 1600 records) as follows:


<P>
<PRE>     8 seconds of user time for input and no output
    10 seconds of user time for input and &quot;quick&quot; output
    16 seconds of user time for input and &quot;safe&quot; output</PRE>



<P>
So, figure the individual speeds are:


<P>
<PRE>    input:            200 records ( 60 KB) per second.
    &quot;quick&quot; output:   800 records (240 KB) per second.
    &quot;safe&quot; output:    200 records ( 60 KB) per second.</PRE>



<P>
By contrast, a C program which does the same work is about 8 times as fast.  
But of course, the C code is 8 times as large, and 8 times as ugly...  <CODE>:-)</CODE>


<P><HR>
<A NAME="note_to_serious_bibfile_users">
<H2><FONT COLOR=#600020>
<A HREF="#__top"><IMG SRC="Refer-gifs/h2bullet.gif" ALT="" BORDER="0"></A>
Note to serious bib-file users</FONT></H2>
</A>


<P>
I actually do not use &quot;refer&quot; files for *roffing... I used them as a
quick-and-dirty database for WebLib, and that's where this code comes
from.  If you're a serious user of &quot;refer&quot; files, and this module doesn't
do what you need it to, please contact me: I'll add the functionality
in.


<P><HR>
<A NAME="bugs">
<H1><FONT COLOR=#600020>
<A HREF="#__top"><IMG SRC="Refer-gifs/h1bullet.gif" ALT="" BORDER="0"></A>
BUGS</FONT></H1>
</A>


<P>
Some combinations of parser-options are silly.


<P><HR>
<A NAME="change_log">
<H1><FONT COLOR=#600020>
<A HREF="#__top"><IMG SRC="Refer-gifs/h1bullet.gif" ALT="" BORDER="0"></A>
CHANGE LOG</FONT></H1>
</A>


<P>
&#36;Id: Refer.pm,v 1.106 1997/04/22 18:41:41 eryq Exp &#36;

<DL>
<P><DT><B><A NAME="version">Version 1.101</A></B><DD>

Initial release.  Adapted from Text::Bib.

</DL>

<P><HR>
<A NAME="author">
<H1><FONT COLOR=#600020>
<A HREF="#__top"><IMG SRC="Refer-gifs/h1bullet.gif" ALT="" BORDER="0"></A>
AUTHOR</FONT></H1>
</A>


<P>
Copyright (C) 1997 by Eryq, 
<I><A HREF="mailto:eryq@enteract.com">eryq@enteract.com</A></I>,
<I><A HREF="http://www.enteract.com/~eryq">http://www.enteract.com/~eryq</A></I>.


<P><HR>
<A NAME="no_warranty">
<H1><FONT COLOR=#600020>
<A HREF="#__top"><IMG SRC="Refer-gifs/h1bullet.gif" ALT="" BORDER="0"></A>
NO WARRANTY</FONT></H1>
</A>


<P>
This program is free software; you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation; either version 2 of the License, or
(at your option) any later version.


<P>
This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.


<P>
For a copy of the GNU General Public License, write to the Free Software
Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.


<P><HR>
<SMALL>
		Last updated: Wed Apr 30 17:32:53 1997 <BR>
		Generated by pod2coolhtml 1.101.  Want a copy?  Just email
		<A HREF="mailto:eryq@enteract.com">eryq@enteract.com</A>.
		(Yes, it's free.)
		</SMALL></BODY>
</HTML>
